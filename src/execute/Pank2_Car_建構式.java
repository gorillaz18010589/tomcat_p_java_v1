package execute;
import prictice.*;
//1.建構式 constructor定義:與類別名稱完全一樣,也有存取修飾字,你只要做了建構式,任何一個類別都有建構式不會沒有,只是不知道來自何方
//*建構式目的:初始化,一開始你希望這個物件長什麼樣子做哪些方法,特徵在哪會在這定義
//*建構式與方法差異:(1)方法會有傳回值型別 (2)建構式永遠沒有傳回值,只是在做初始化的事情
//*建構式如果沒有做:(extends Object的預設)其實有預設建構式,只是目前看不到,你的創始人是Object,所以如果沒有寫建構式,他自動幫你定義建構視為Object
//*所有的類別class祖先創始人都是:Object
//*建構式沒有寫的話:將會找你爸爸肚子裡面,沒有傳遞參數的那個建構式,來當你的建構式
//*你寫了建構式的話:當然要尊重你,那爸爸的建構式就沒用了,以你為主
//*建構式不是繼承傭有的觀念:只是因為你沒有建構式,才拿爸爸沒有參數的建構式給你,你有寫的話尊重你

//(6.1):public Car(int a):加了int a參數,(1)那你初始化的物件也要帶餐數處理紅單(2)Lexux也在哭,因為Car爸爸沒有無船參數的建構式,所以你要自己做建構式
//*Super:你Lexux只是單純繼承,為什麼就可以有爸爸的加速度方法等,因為其實在建構時的時候,他就偷偷Super(叫爸)
//*Super觀念:有你的存在,你爸爸就要存在,你阿公就要存在,不然你怎麼叫得出爸爸跟阿公的方法
//*Super叫爸:任何建構式的第一道敘述句:就是將你祖宗八代叫進來的,因為你之所以存在是因為你爸爸,你爸爸之所以存在是因為你阿公,你叫你爸爸(super),你爸爸Car也(Super叫爸)
//*Super目的:就是讓你extends可以直接叫爸爸,用爸爸的方法,就是因為有再叫爸
//*Java建構式設計:(1)單純設計 (2)找你爸爸沒有傳參數的建構式當唯一建構式 (3)如果你沒有建構式無傳參數的就給你抱錯 (4)那你兒子就Super叫爸給參數
public class Pank2_Car_建構式 {

	public static void main(String[] args) {
		//1.建構式初始化概念
		Car c1 = new Car(1); //有呼叫Car() 因為做了建構式定義,如果沒寫建構式,也會自動幫你叫祖先Object的建構式偷偷執行
//		 =:在做的事情就是把c1變數進行初始化
//		 new:記憶體配置一個新的空間
//		 Car():進行初始化給值的動作
		
		//2.建構式偷偷super叫爸概念
		Lexux l1 = new Lexux();
		
		

	}

}
