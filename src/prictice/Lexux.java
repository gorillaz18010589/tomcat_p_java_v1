package prictice;
//1.建構式 constructor定義:與類別名稱完全一樣,也有存取修飾字,你只要做了建構式,任何一個類別都有建構式不會沒有,只是不知道來自何方
//*建構式目的:初始化,一開始你希望這個物件長什麼樣子做哪些方法,特徵在哪會在這定義
//*建構式與方法差異:(1)方法會有傳回值型別 (2)建構式永遠沒有傳回值,只是在做初始化的事情
//*建構式如果沒有做:(extends Object的預設)其實有預設建構式,只是目前看不到,你的創始人是Object,所以如果沒有寫建構式,他自動幫你定義建構視為Object
//*所有的類別class祖先創始人都是:Object
//*建構式沒有寫的話:將會找你(爸爸肚子裡面,沒有傳遞參數的那個建構式,來當你的建構式)
//*你寫了建構式的話:當然要尊重你,那爸爸的建構式就沒用了,以你為主
//*建構式不是繼承傭有的觀念:只是因為你沒有建構式,才拿爸爸沒有參數的建構式給你,你有寫的話尊重你

//(6.1):public Car(int a):加了int a參數,(1)那你初始化的物件也要帶餐數處理紅單(2)Lexux也在哭,因為Car爸爸沒有無船參數的建構式,所以你要自己做建構式
//*Super:你Lexux只是單純繼承,為什麼就可以有爸爸的加速度方法等,因為其實在建構時的時候,他就偷偷Super(叫爸)
//*Super觀念:有你的存在,你爸爸就要存在,你阿公就要存在,不然你怎麼叫得出爸爸跟阿公的方法
//*Super叫爸:任何建構式的第一道敘述句:就是將你祖宗八代叫進來的,因為你之所以存在是因為你爸爸,你爸爸之所以存在是因為你阿公,你叫你爸爸(super),你爸爸Car也(Super叫爸)
//*Super目的:就是讓你extends可以直接叫爸爸,用爸爸的方法,就是因為有再叫爸
//*Java建構式設計:(1)單純設計 (2)找你爸爸沒有傳參數的建構式當唯一建構式 (3)如果你沒有建構式無傳參數的就給你抱錯 (4)那你兒子就Super叫爸給參數


public class Lexux extends Car{
		private boolean light; //燈的屬性因為要開關所以用boolean,一開始未設定的劃初始值是false
		
		//(6.1):public Car(int a):加了int a參數,(1)那你初始化的物件也要帶餐數處理紅單(2)Lexux也在哭,因為Car爸爸沒有無船參數的建構式,所以你要自己做建構式
	public Lexux () {
		super(2); //叫爸,初始化,這裡要帶參數2,因為爸爸(Car)沒有寫無傳參數的建構式,所以把參數丟進去配合爸爸有傳參數建構式就完成
		System.out.println();
	}
		
		//取得燈狀態方法
	public boolean isLight() {return light;} //取得燈的狀態方法
		
		//切換燈方法
	public void switchLight() {
			light = !light; //假設一開始是false,!代表非,所以   !light == 不是false(燈),就是亮燈(true)的意思,存入到light
							//第二次 !light == 不是true(燈),就是false(關燈)存入到Light				
			}
		
		//protected概念:(讓兒子可以玩屬性,但其他人不能亂玩)因為爸爸Car有upSpeed方法,我這邊也想要有,發現玩到Speed我卻不認識,因為爸爸把他Private了,所以你必須改成保護方式,讓兒子可以玩,但其他人步行
	public void upSpeed() {
			spped = spped <1 ?1 : spped*3.6;
		}
}
