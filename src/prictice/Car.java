package prictice;
//1.這邊是汽車類別
//*在意汽車的速度怎麼樣,我打算用double來表現 //double spped;
//*Field欄位概念:像你填表格,姓名男,年齡18等等概念 == private double spped; //屬性 // 但在api裡面稱為:Field(欄位)
//*定義類別的規則:如果是class的話首字大寫,如果是屬性通常是全小寫

//2.你要讓汽車跑,就必須踩油門所以需要方法void upSpeed()
//2.1你要讓汽車減速所以也需要減速度方法void downSpeed() 
//*設計類別目的:設計一個類別我在意的是屬性,像汽車速度多少,你有那些屬性才會搭配方法去支援屬性,值得改變
//*例如:這邊有一個杯子(class)如何讓它水(屬性)增加變多,加水去進去(void加水方法),喝掉(void喝水方法),這些叫做動態的方法
//*我在意的是他有多少水(屬性),所以我有加水跟喝水方法去處理
//*設計類別理念:要提供什麼樣的功能,例如生產汽車,汽車有加速度跟減速度你就加上去,你不需要去注意要不要甩尾等,簡單去處理,越單純越好

//*Private(封裝)概念:是因為你汽車不能直接用c1.spped = 10;的方式直接讓使用者看到速度在修改,不合理,所以(為了讓使用者不准亂改要Private封裝起來)
//*getSpeed(裝時速表概念):因為你Private屬性,消費者就看不到速度了,所以你要如何知道你汽車時速,你需要裝時速表,所以才要getSpeed;
//*概念:你要改變速度要透過我的方法void,你要看時速我會安裝時速表getSpeed()方法給你,讓你看的到卻不能亂玩我們的屬性Speed速度

//Pank22執行到以上=========================================================================

//*4.(一個原始檔中只能有一個class是public)類似public class Car 其檔名要跟他一樣,其他的class不能是public,
//*沒有存取修飾字:class Lexux因為沒有寫Public等任存取修飾字,所以這個class(只有相同的Pakage可以存取他)
//extends:概念是繼承,延伸擴大Car,重點是(發揚光大)
//extends概念第一條:(可以玩父類別的方法)extends完全繼承了Car(爸爸)的方法,所以我Lexux目前沒寫任何方法,卻可以玩爸爸留下的方法
//*但因為extends目的是發揚光大,你什麼都沒寫,靠你爸爸叫做不長進
//4.1發揚光大:加上ligit的燈屬性,開燈跟關燈方法,這邊切換開關用boorlean,如果你要分段開燈用int也型看個人

//Pank23_執行Lexux執行到以上================================

//5.protected概念:(相同Pakcge跟兒子可以玩屬性,但其他人不能亂玩)因為爸爸Car有upSpeed方法,我這邊也想要有,發現玩到Speed我卻不認識
//因為爸爸把他Private了,所以你必須改成protected方式,讓兒子可以玩,但其他人步行
//創建execute的Package:負責執行呼叫這邊的類別

//Import:將不同Package的Class類別讓你可以玩
//1.(一個原始檔中只能有一個class是public):所以Lexux寫在Car裡面玩不到
//2.Public:讓全世界都可以玩的到

//Pank1_Lexux_不同Pakceage存取修飾字 =================================

//has-a member成員: obj.member
//Method:public void upSpeed()等三個都叫方法
//區域變數:{在這括號內的變數}
//全域變數:cass{在Calss第一層的變數}

//6.建構式 constructor定義:與類別名稱完全一樣,也有存取修飾字
//*建構式目的:初始化,一開始你希望這個物件長什麼樣子做哪些方法,特徵在哪會在這定義
//*建構式與方法差異:(1)方法會有傳回值型別 (2)建構式永遠沒有傳回值,只是在做初始化的事情
//*建構式如果沒有做:(extends Object的預設)其實有預設建構式,只是目前看不到,你的創始人是Object,所以如果沒有寫建構式,他自動幫你定義建構視為Object
//*所有的類別class祖先創始人都是:Object
//*建構式沒有寫的話:將會找你爸爸肚子裡面,沒有傳遞參數的那個建構式,來當你的建構式
//*你寫了建構式的話:當然要尊重你,那爸爸的建構式就沒用了,以你為主
//*建構式不是繼承傭有的觀念:只是因為你沒有建構式,才拿爸爸沒有參數的建構式給你,你有寫的話尊重你

//(6.1):public Car(int a):加了int a參數,(1)那你初始化的物件也要帶餐數處理紅單(2)Lexux也在哭,因為Car爸爸沒有無船參數的建構式,所以你要自己做建構式
//*Super:你Lexux只是單純繼承,為什麼就可以有爸爸的加速度方法等,因為其實在建構時的時候,他就偷偷Super(叫爸)
//*Super觀念:有你的存在,你爸爸就要存在,你阿公就要存在,不然你怎麼叫得出爸爸跟阿公的方法
//*Super叫爸:任何建構式的第一道敘述句:就是將你祖宗八代叫進來的,因為你之所以存在是因為你爸爸,你爸爸之所以存在是因為你阿公,你叫你爸爸(super),你爸爸Car也(Super叫爸)
//*Super目的:就是讓你extends可以直接叫爸爸,用爸爸的方法,就是因為有再叫爸
//*Java建構式設計:(1)單純設計 (2)找你爸爸沒有傳參數的建構式當唯一建構式 (3)如果你沒有建構式無傳參數的就給你抱錯 (4)那你兒子就Super叫爸給參數//pank2執行

//Pink3執行到以上========================================

//建構式可以有多個:(1)無傳參數 (2)有傳參數 (3)只要參數個數型別不一樣都可以形成建構式
//建構式參數(個數)(型別)要不一樣:就像你建構式一模一樣,我怎知道你要叫誰
//建構式沒有繼承的概念:繼承的東西,只有數性跟方法而已,他會去找你爸爸建構式無參數的那招
//建構式會先叫爸再來才執行你的東西
//不管有傳參數無傳參數建構式:第一句都會Super(叫爸)

//overloaded建構式概念:(1)Class建構式名字一樣,但參數個數不同,所形成的現象
//overloaded方法概念也是

//Pank2,Pank3執行以上==============================

//Java 8 api文件回顧概念
//final(最終)概念:絕子決孫概念,就不讓你繼承,最後一代的概念

public class Car { //沒有存取修飾字:(只有相同Pakcge可以玩)因為前面沒有任何封裝或處理
	//*在意汽車的速度怎麼樣,我打算用double來表現
	protected double spped; //屬性 // 但在api裡面稱為:Field(欄位)
	
	//6.建構式 constructor定義:與類別名稱完全一樣不能兩樣,也有存取修飾字,只要長相不一樣就不是建構式
	//(6.1):public Car(int a):加了int a參數,(1)那你初始化的物件也要帶餐數處理紅單(2)Lexux也在哭,因為Car爸爸沒有無船參數的建構式,所以你要自己做建構式
	public Car(int a) {	
		System.out.println("Car()");	
		}
	
	
	//2.(void家速度方法)你要讓汽車跑,就必須踩油門所以需要方法void upSpeed()
	//Method方法
   public void upSpeed() {
		spped = spped<1 ? 1 : spped*1.2; //一開始為0如果小於1,代表踩第一下讓她速度為1,否則大於1的話讓他加速度變成1.2倍
	}
	
	//*2.1(void減速度方法)你要讓汽車減速所以也需要減速度方法void downSpeed() 
   public void downSpeed() {
		spped = spped<1 ? 0 : spped*0.7;  //當你速度小於1時再踩一下,就讓你變速度0,否則大於1的狀況就是以0.7被減速煞車
	}
	
	//3.getSpeed(裝時速表概念):因為你Private屬性,消費者就看不到速度了,所以你要如何知道你汽車時速,你需要裝時速表,所以才要getSpeed;
	public double getSpeed() {
		return spped;
	}
}
//4.一個原始檔中只能有一個類別是public類似public class Car 其檔名要跟他一樣,其他的class不能是public,所以這邊不能用public
//extends:概念是繼承,延伸擴大Car,重點是發揚光大
//這邊是示範一個原始檔中只有一個Class可以Public被大家使用,後來另外寫了Lexux類別
//class Lexux extends Car{
	
	//4.1 開始發揚光大要裝燈
//	private boolean light; //燈的屬性因為要開關所以用boolean,一開始未設定的劃初始值是false
//	
//	//取得燈狀態方法
//	boolean isLight() {return light;} //取得燈的狀態方法
//	
//	//切換燈方法
//	void switchLight() {
//		light = !light; //假設一開始是false,!代表非,所以   !light == 不是false(燈),就是亮燈(true)的意思,存入到light
//						//第二次 !light == 不是true(燈),就是false(關燈)存入到Light				
//		}
//	
//	//5.protected概念:(讓兒子可以玩屬性,但其他人不能亂玩)因為爸爸Car有upSpeed方法,我這邊也想要有,發現玩到Speed我卻不認識,因為爸爸把他Private了,所以你必須改成保護方式,讓兒子可以玩,但其他人步行
//	void upSpeed() {
//		spped = spped <1 ?1 : spped*3.6;
	
